from typing import Annotated

RANK_THRESHOLD = Annotated[
    float,
    {
        "label": "Minimum threshold for auto selection",
        "tooltip": (
            "Only classes with a pre dicted threshold above this value will be "
            "selected."
        ),
    },
]
SELECT_NR_PARTS = Annotated[
    int | None,
    {
        "label": "Minimum number of particles to select",
        "tooltip": (
            "Even if they have scores below the minimum threshold, select at least "
            "this many particles with the best scores."
        ),
        "min": 1,
    },
]
SELECT_NR_CLASSES = Annotated[
    int | None,
    {
        "label": "Or minimum number of classes to select",
        "tooltip": (
            "Even if they have scores below the minimum threshold, select at least "
            "this many classes with the best scores."
        ),
        "min": 1,
    },
]
DO_RECENTER = Annotated[
    bool,
    {
        "label": "Recenter the class averages",
        "tooltip": (
            "This option is only used when selecting particles from 2D classes. The "
            "selected class averages will all re-centered on their center-of-mass. "
            "This is useful when you plane to use these class averages as templates "
            "for auto-picking."
        ),
    },
]
DO_REGROUP = Annotated[
    bool,
    {
        "label": "Regroup the particles",
        "tooltip": (
            "If set to Yes, then the program will regroup the selected particles in "
            "'more-or-less' the number of groups indicated below. For re-grouping from "
            "individual particle _data.star files, a _model.star file with the same "
            "prefix should exist, i.e. the particle star file should be generated by "
            "relion_refine"
        ),
    },
]
NR_GROUPS = Annotated[
    int,
    {
        "label": "Approximate number of groups",
        "tooltip": (
            "It is normal that the actual number of groups may deviate a little from "
            "this number."
        ),
    },
]
SELECT_LABEL = Annotated[
    str,
    {
        "label": "Metadata label for selection",
        "tooltip": (
            "This column from the input STAR file will be used for the subset "
            "selection."
        ),
    },
]
SELECT_MINVAL = Annotated[
    float,
    {
        "label": "Minimum value for selection",
        "tooltip": (
            "Only lines in the input STAR file with the corresponding metadata value "
            "larger than or equal to this value will be included in the subset."
        ),
    },
]
SELECT_MAXVAL = Annotated[
    float,
    {
        "label": "Maximum value for selection",
        "tooltip": (
            "Only lines in the input STAR file with the corresponding metadata value "
            "smaller than or equal to this value will be included in the subset."
        ),
    },
]
DUPLICATE_THRESHOLD = Annotated[
    float,
    {
        "label": "Minimum inter-particle distance (A)",
        "tooltip": (),
    },
]
IMAGE_ANGPIX = Annotated[
    float | None,
    {
        "label": "Image pixel size (A)",
        "tooltip": (
            "The pixel size of particles (relevant to rlnOriginX/Y) is read from the "
            "STAR file. When the pixel size of the original micrograph used for "
            "auto-picking and extraction (relevant to rlnCoordinateX/Y) is different, "
            "specify it here. In other words, this is the pixel size after binning "
            "during motion correction, but before down-sampling during extraction."
        ),
        "min": 0.0,
    },
]
DO_RANDOM = Annotated[
    bool,
    {
        "label": "Randomise order before making subsets",
        "tooltip": (
            "If set to Yes, the input STAR file order will be randomised. If set to "
            "No, the original order in the input STAR file will be maintained."
        ),
    },
]
SPLIT_SIZE = Annotated[
    int | None,
    {
        "label": "Number of particles per subset",
        "tooltip": (
            "The number of lines in each of the output subsets. When this is not "
            "given, items are divided into a number of subsets specified in the next "
            "option."
        ),
        "min": 1,
    },
]
NR_SPLIT = Annotated[
    int,
    {
        "label": "Or number of subsets",
        "tooltip": (
            "Give a positive integer to specify into how many equal-sized subsets the "
            "data will be divided. When the subset size is also specified, only this "
            "number of subsets, each with the specified size, will be written, "
            "possibly missing some items. When this is -1, all items are used, "
            "generating as many subsets as necessary."
        ),
        "min": 1,
    },
]
DENDROGRAM_THRESHOLD = Annotated[
    float,
    {
        "label": "Dendrogram threshold",
        "tooltip": (
            "Lower thresholds will produce more clusters; After the dendrogram has "
            "been calculated in the initial running of this job, subsequent "
            "continuation jobs can quickly test other threshold values. The output "
            "logfile.pdf can be visualised to follow the process until a good "
            "threshold has been achieved."
        ),
    },
]
DENDROGRAM_MINCLASS = Annotated[
    int,
    {
        "label": "Minimum class size",
        "tooltip": (
            "If set to a positive value, then particle star files with clusters that "
            "have at least this number of particles will be written out. Keep this "
            "default negative value for faster testing of the threshold."
        ),
    },
]
