from pathlib import Path
from typing import Annotated

from himena_relion._widgets._path_input import PathDrop


FN_DATA_MIC = Annotated[
    str,
    {
        "label": "Micrographs (from MotionCorr)",
        "widget_type": PathDrop,
        "type_label": ["MicrographsData", "MicrographGroupMetadata"],
        "tooltip": (
            "The input STAR file with the micrograph (and their movie metadata) from a "
            "MotionCorr job."
        ),
        "group": "I/O",
    },
]
FN_DATA_POLISH = Annotated[
    str,
    {
        "label": "Particles (from Refine3D or CtfRefine)",
        "widget_type": PathDrop,
        "type_label": ["ParticlesData", "ParticleGroupMetadata"],
        "tooltip": "The input STAR file with the metadata of all particles.",
        "group": "I/O",
    },
]
FN_POST = Annotated[
    str,
    {
        "label": "Postprocess STAR file",
        "widget_type": PathDrop,
        "type_label": "ProcessData",
        "tooltip": (
            "The STAR file generated by a PostProcess job. The mask used for this "
            "postprocessing will be applied to the unfiltered half-maps and should "
            "encompass the entire complex. The resulting FSC curve will be used for "
            "weighting the different frequencies."
        ),
        "group": "I/O",
    },
]
FIRST_FRAME = Annotated[
    int,
    {
        "label": "First movie frame",
        "tooltip": (
            "First movie frame to take into account in motion fit and combination step"
        ),
        "group": "I/O",
    },
]
LAST_FRAME = Annotated[
    int,
    {
        "label": "Last movie frame",
        "tooltip": (
            "Last movie frame to take into account in motion fit and combination step. "
            "Values equal to or smaller than 0 mean 'use all frames'."
        ),
        "group": "I/O",
    },
]
EXTRACT_SIZE = Annotated[
    int | None,
    {
        "label": "Extraction size (pix in unbinned movie)",
        "tooltip": (
            "Size of the extracted particles in the unbinned original movie (in "
            "pixels). This should be an even number."
        ),
        "group": "I/O",
    },
]
RESCALE = Annotated[
    int | None,
    {
        "label": "Rescaled size (pixels)",
        "tooltip": "The re-scaled value needs to be an even number.",
        "group": "I/O",
    },
]
# Train
EVAL_FRAC = Annotated[
    float,
    {
        "label": "Fraction of Fourier pixels for testing",
        "tooltip": (
            "This fraction of Fourier pixels (at higher resolution) will be used for "
            "evaluation of the parameters (test set), whereas the rest (at lower "
            "resolution) will be used for parameter estimation itself (work set)."
        ),
        "group": "I/O",
    },
]
OPTIM_MIN_PART = Annotated[
    int,
    {
        "label": "Use this many particles",
        "tooltip": (
            "Use at least this many particles for the meta-parameter optimisation. "
            "The more particles the more expensive in time and computer memory the "
            "calculation becomes, but the better the results may get."
        ),
        "group": "I/O",
    },
]


DO_OWN_PARAMS = Annotated[
    bool,
    {
        "label": "Use your own parameters",
        "tooltip": (
            "If enabled, then the field for the optimised parameter file will be "
            "ignored and the parameters specified below will be used instead."
        ),
        "group": "Polish",
    },
]
OPT_PARAMS = Annotated[
    Path,
    {
        "label": "Optimised parameter file",
        "filter": "Polish parameter file (*.txt)",
        "tooltip": (
            "The output TXT file from a previous Bayesian polishing job in which the "
            "optimal parameters were determined."
        ),
        "group": "Polish",
    },
]
SIGMA_VEL = Annotated[
    float,
    {
        "label": "Sigma for velocity (A/dose)",
        "tooltip": (
            "Standard deviation for the velocity regularisation. Smaller values "
            "requires the tracks to be shorter."
        ),
        "group": "Polish",
    },
]
SIGMA_DIV = Annotated[
    float,
    {
        "label": "Sigma for divergence (A)",
        "tooltip": (
            "Standard deviation for the divergence of tracks across the micrograph. "
            "Smaller values requires the tracks to be spatially more uniform in a "
            "micrograph."
        ),
        "group": "Polish",
    },
]
SIGMA_ACC = Annotated[
    float,
    {
        "label": "Sigma for acceleration (A/dose)",
        "tooltip": (
            "Standard deviation for the acceleration regularisation. Smaller values "
            "requires the tracks to be straighter."
        ),
        "group": "Polish",
    },
]
MINRES = Annotated[
    float,
    {
        "label": "Minimum resolution for B-factor fit (A)",
        "tooltip": (
            "The minimum spatial frequency (in Angstrom) used in the B-factor fit."
        ),
        "group": "Polish",
    },
]
MAXRES = Annotated[
    float | None,
    {
        "label": "Maximum resolution for B-factor fit (A)",
        "tooltip": (
            "The maximum spatial frequency (in Angstrom) used in the B-factor fit. If "
            "a negative value is given, the maximum is determined from the input FSC "
            "curve."
        ),
        "group": "Polish",
    },
]
