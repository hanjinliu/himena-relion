from typing import Annotated

from himena_relion._widgets._path_input import PathDrop


FN_DATA_MIC = Annotated[
    str,
    {
        "label": "Micrographs (from MotionCorr)",
        "widget_type": PathDrop,
        "type_label": ["MicrographsData", "MicrographGroupMetadata"],
        "allowed_extensions": [".star"],
        "tooltip": (
            "The input STAR file with the micrograph (and their movie metadata) from a "
            "MotionCorr job."
        ),
        "group": "I/O",
    },
]
FN_DATA_POLISH = Annotated[
    str,
    {
        "label": "Particles (from Refine3D or CtfRefine)",
        "widget_type": PathDrop,
        "type_label": ["ParticlesData", "ParticleGroupMetadata"],
        "allowed_extensions": [".star"],
        "tooltip": "The input STAR file with the metadata of all particles.",
        "group": "I/O",
    },
]
FN_POST = Annotated[
    str,
    {
        "label": "Postprocess STAR file",
        "widget_type": PathDrop,
        "type_label": "ProcessData",
        "allowed_extensions": [".star"],
        "tooltip": (
            "The STAR file generated by a PostProcess job. The mask used for this "
            "postprocessing will be applied to the unfiltered half-maps and should "
            "encompass the entire complex. The resulting FSC curve will be used for "
            "weighting the different frequencies."
        ),
        "group": "I/O",
    },
]
FIRST_FRAME = Annotated[
    int,
    {
        "label": "First movie frame",
        "tooltip": (
            "First movie frame to take into account in motion fit and combination step"
        ),
        "group": "I/O",
    },
]
LAST_FRAME = Annotated[
    int,
    {
        "label": "Last movie frame",
        "tooltip": (
            "Last movie frame to take into account in motion fit and combination step. "
            "Values equal to or smaller than 0 mean 'use all frames'."
        ),
        "group": "I/O",
    },
]
EXTRACT_SIZE = Annotated[
    int | None,
    {
        "label": "Extraction size (pix in unbinned movie)",
        "tooltip": (
            "Size of the extracted particles in the unbinned original movie (in "
            "pixels). This should be an even number."
        ),
        "group": "I/O",
    },
]
RESCALE = Annotated[
    int | None,
    {
        "label": "Rescaled size (pixels)",
        "tooltip": "The re-scaled value needs to be an even number.",
        "group": "I/O",
    },
]
# Train
EVAL_FRAC = Annotated[
    float,
    {
        "label": "Fraction of Fourier pixels for testing",
        "tooltip": (
            "This fraction of Fourier pixels (at higher resolution) will be used for "
            "evaluation of the parameters (test set), whereas the rest (at lower "
            "resolution) will be used for parameter estimation itself (work set)."
        ),
        "group": "I/O",
    },
]
OPTIM_MIN_PART = Annotated[
    int,
    {
        "label": "Use this many particles",
        "tooltip": (
            "Use at least this many particles for the meta-parameter optimisation. "
            "The more particles the more expensive in time and computer memory the "
            "calculation becomes, but the better the results may get."
        ),
        "group": "I/O",
    },
]


DO_OWN_PARAMS = Annotated[
    bool,
    {
        "label": "Use your own parameters",
        "tooltip": (
            "If enabled, then the field for the optimised parameter file will be "
            "ignored and the parameters specified below will be used instead."
        ),
        "group": "Polish",
    },
]
OPT_PARAMS = Annotated[
    str,
    {
        "label": "Optimised parameter file",
        "widget_type": PathDrop,
        "allowed_extensions": [".txt"],
        "tooltip": (
            "The output TXT file from a previous Bayesian polishing job in which the "
            "optimal parameters were determined."
        ),
        "group": "Polish",
    },
]
SIGMA_VEL = Annotated[
    float,
    {
        "label": "Sigma for velocity (A/dose)",
        "tooltip": (
            "Standard deviation for the velocity regularisation. Smaller values "
            "requires the tracks to be shorter."
        ),
        "group": "Polish",
    },
]
SIGMA_DIV = Annotated[
    float,
    {
        "label": "Sigma for divergence (A)",
        "tooltip": (
            "Standard deviation for the divergence of tracks across the micrograph. "
            "Smaller values requires the tracks to be spatially more uniform in a "
            "micrograph."
        ),
        "group": "Polish",
    },
]
SIGMA_ACC = Annotated[
    float,
    {
        "label": "Sigma for acceleration (A/dose)",
        "tooltip": (
            "Standard deviation for the acceleration regularisation. Smaller values "
            "requires the tracks to be straighter."
        ),
        "group": "Polish",
    },
]
MINRES = Annotated[
    float,
    {
        "label": "Minimum resolution for B-factor fit (A)",
        "tooltip": (
            "The minimum spatial frequency (in Angstrom) used in the B-factor fit."
        ),
        "group": "Polish",
    },
]
MAXRES = Annotated[
    float | None,
    {
        "label": "Maximum resolution for B-factor fit (A)",
        "tooltip": (
            "The maximum spatial frequency (in Angstrom) used in the B-factor fit. If "
            "a negative value is given, the maximum is determined from the input FSC "
            "curve."
        ),
        "group": "Polish",
    },
]

# Tomograms
BOX_SIZE = Annotated[
    int,
    {
        "label": "Box size for estimation (pix)",
        "tooltip": (
            "Box size to be used for the estimation. Note that this can be larger than "
            "the box size of the reference map. A sufficiently large box size allows "
            "more of the high-frequency signal to be captured that has been "
            "delocalised by the CTF."
        ),
        "group": "Polish",
    },
]
MAX_ERROR = Annotated[
    int,
    {
        "label": "Max position error (pix)",
        "tooltip": (
            "maximal assumed error in the initial 2D particle-positions (distances "
            "between the projected 3D positions and their true positions in the "
            "images), given in pixels."
        ),
        "group": "Polish",
    },
]
DO_SHIFT_ALIGN = Annotated[
    bool,
    {
        "label": "Align by shift only",
        "tooltip": (
            "If set to Yes, tilt series projection shifts are refined based on "
            "cross-correlation. Useful for very badly aligned frames. No iterative "
            "optimisation."
        ),
        "group": "Polish",
    },
]
SHIFT_ALIGN_TYPE = Annotated[
    str,
    {
        "label": "Alignment model",
        "choices": ["Entire micrographs", "Only particles"],
        "tooltip": (
            'If set to "Only particles", it estimates rigid shift by aligning only '
            "the particles instead of by predicting entire micrographs. In this case, "
            "only misalignments smaller than half the box size of the particle can be "
            "corrected."
        ),
        "group": "Polish",
    },
]
DO_MOTION = Annotated[
    bool,
    {
        "label": "Fit per-particle motion",
        "tooltip": (
            "If set to Yes, then the subtomogram version of Bayesian polishing will be "
            "used to fit per-particle (3D) motion tracks, besides the rigid part of the "
            "motion in the tilt series."
        ),
        "group": "Polish",
    },
]
DO_SQ_EXP_KER = Annotated[
    bool,
    {
        "label": "Use Gaussian decay",
        "tooltip": (
            "If set to Yes, then assume that the correlation of the velocities of two "
            "particles decays as a Gaussian over their distance, instead of as an "
            "exponential. This will produce spatially smoother motion and result in a "
            "shorter program runtime."
        ),
        "group": "Polish",
    },
]
