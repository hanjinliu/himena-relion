{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"himena-relion","text":"<p><code>himena-relion</code> is a modern RELION GUI implemented as a himena plugin.</p> <p></p> <p>For the details of the jobs and algorithms, please refer to the RELION documentation.</p> <ul> <li> <p> Installation</p> </li> <li> <p> Getting Started</p> </li> <li> <p> External Jobs</p> </li> </ul>"},{"location":"getting_started/","title":"Getting Started","text":"<p>Run</p> <pre><code>himena relion\n</code></pre> <p>to launch the application.</p>"},{"location":"getting_started/#configuration","title":"Configuration","text":"<p>Before starting your image processing, you need to configure the paths to executables and scripts that RELION jobs will call.</p> <p>Open the himena setting dialog (Ctrl+,) and select the \"Configurations\" tab. Type \"relion\" in the search bar, and you will see the configuration items related to RELION as shown below.</p> <p></p> <p>These values will be automatically used for the RELION jobs that take these executables or scripts as input.</p> <p>Note</p> <p>You can further customize the application, including dark background, keybinding, font etc. Please refer to the himena documentation.</p>"},{"location":"getting_started/#launch-existing-relion-project","title":"Launch Existing RELION Project","text":"<p><code>himena-relion</code> and RELION GUI is compatible. If you have an existing RELION project, just run <code>himena relion</code> under the project directory</p> <pre><code>cd path/to/my-project\nhimena relion &amp;\n</code></pre> <p>or pass the project path as an argument</p> <pre><code>himena relion path/to/my-project &amp;\n</code></pre> <p>You can also open a RELION project by:</p> <ul> <li>Ctrl+O and select the default_pipeline.star file.</li> <li>from the \"Recent Files\" in the startup window.</li> <li>from the recent-file command palette (Ctrl+K \u2192 Ctrl+R)</li> </ul>"},{"location":"getting_started/#create-new-relion-project","title":"Create New RELION Project","text":"<p>If RELION project is not initialized in the current directory yet, you'll have to create one. You can do this by opening the command palette (Ctrl+Shift+P) and running the \"Start New RELION Project\" command.</p> <p></p> <p>Once the default_pipeline.star file is created, you'll see a dock widget on the left. You can click any of the import jobs to start processing your data.</p> <p></p>"},{"location":"getting_started/#job-flowchart","title":"Job Flowchart","text":"<p>If your RELION project has jobs, the job flowchart will automatically created.</p> <p></p> <p>In this flowchart, you can double-click nodes to open the job window.</p>"},{"location":"getting_started/#job-window","title":"Job Window","text":"<p>A job window displays the content of the job directory. For most of the cases, the first tab will show the most informative representation of the job outputs, such as the processed micrographs, reconstructed particles, or 2D class images.</p> <p>Each job window runs an independent file watcher so that the content will be automatically updated (in reasonable time intervals).</p> <p></p> <p>The top-left corner has useful actions.</p> <p>The tool button 1 contains actions that are related to RELION job windows (no matter what job it is), such as \"Overwrite\" and \"Mark As Finished\".</p> <p>The tool button 2 contains hints for the next actions. For example, in a 2D classification job window, you will see \"Select Class\". These action hints are very convenient way to run the next job, as the input parameters will be automatically filled.</p>"},{"location":"getting_started/#scheduling-next-jobs","title":"Scheduling Next Jobs","text":"<p>To run the next job, you can: - Click the action hint in the job window - Open the command palette (Ctrl+Shift+P) and type the name of the job you want to   run. - In the menubar, go to \"Tools &gt; RELION\" and find the job you want to run.</p> <p></p> <ul> <li> <p>By clicking the \"Run\" button, a job.star file will be created and passed to   <code>relion_pipeliner</code>, which will organize the job pipeline and run the job.</p> </li> <li> <p>You can drag-and-drop the items in the input/output panels to fill some of the job   parameters (yellow line).</p> </li> </ul> <p>Note</p> <p>Some of the RELION built-in jobs are split into different job types in <code>himena-relion</code>. For example, the \"Motion correction\" job in RELION is split into \"Motion Correction (MotionCor2)\" and \"Motion Correction (RELION)\". They are the same job type when viewed in RELION GUI, but look different in <code>himena-relion</code>. This is because many RELION built-in jobs have incompatible input parameters that could be confusing for beginners (e.g. \"Write output in float16\" is incompatible with \"Use RELION's own implementation\"). In <code>himena-relion</code>, parameter fields are re-categorized so that running jobs is more straightforward.</p> <p>Job scheduling</p> <p><code>himena-relion</code> automatically schedules the job instead of running it immediately, when any of the input files are not ready or any of the parent job is not finished. This feature is currently integrated with the file watcher for default_pipeline.star so that the scheduled jobs will not automatically start if you quit the <code>himena</code> process.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#1-install-relion","title":"1. Install RELION","text":"<p>Currently <code>himena-relion</code> only supports RELION 5.0.x. Please follow the instructions in the RELION documentation.</p>"},{"location":"installation/#2-create-a-python-environment","title":"2. Create a Python environment","text":"<p>Installation in a Python virtual environment is recommended to avoid conflicts with other packages. For example, you can use miniforge to create a minimum conda environment in your user directory.</p>"},{"location":"installation/#3-install-himena-relion","title":"3. Install <code>himena-relion</code>","text":"<p>Activate the Python environment you created in the previous step, and then run the following command to install <code>himena-relion</code>:</p> <pre><code>pip install himena-relion[recommended]\n</code></pre>"},{"location":"installation/#4-make-himena-relion-command","title":"4. Make <code>himena relion</code> command","text":"<p>You can create a \"profile\" for use of <code>himena</code> as a RELION GUI. Practically, if you name your profile <code>relion</code>, you will register <code>himena relion</code> subcommand as a shortcut to launch the RELION GUI.</p> <p>Following lines will create a <code>relion</code> profile and activate <code>himena-relion</code> plugin in the profile.</p> <pre><code>himena --new relion  # create a new profile named \"relion\"\nhimena relion --install himena-relion  # install the plugin into \"relion\" profile\n</code></pre> <p>Now, you can launch the RELION GUI.</p> <pre><code>himena relion\nhimena relion &amp;  # launch the GUI in the background\n</code></pre>"},{"location":"external_jobs/builtin/","title":"Built-in External Jobs","text":""},{"location":"external_jobs/builtin/#general-purpose-jobs","title":"General-Purpose Jobs","text":""},{"location":"external_jobs/builtin/#symmetry-expansion","title":"Symmetry Expansion","text":"<p>This job uses <code>relion_particle_symmetry_expand</code> to create a new particle star file with expanded particles.</p>"},{"location":"external_jobs/builtin/#helical-symmetry-expansion","title":"Helical Symmetry Expansion","text":"<p>This job uses <code>relion_particle_symmetry_expand</code> to create a new particle star file with helical symmetry expanded particles.</p>"},{"location":"external_jobs/builtin/#shift-map","title":"Shift Map","text":"<p>This job uses the <code>relion_star_handler</code> and a custom-built function to create a shifted particles, map and mask. If you make a 3D reconstruction using the shifted particles, the resulting map will be similar to the shifted map.</p> <p>Common usage of this job will be:</p> <ul> <li>Re-center particles to the region of interest after 3D classification.</li> <li>Re-center particles to the subunits after symmetry expansion.</li> </ul>"},{"location":"external_jobs/builtin/#tomography-specific-jobs","title":"Tomography-specific Jobs","text":""},{"location":"external_jobs/builtin/#find-beads-3d","title":"Find Beads 3D","text":"<p>This job uses the <code>findbeads3d</code> program from IMOD to locate fiducial gold beads in tomograms. The output files are IMOD .mod files. You can check the results in the job widget.</p>"},{"location":"external_jobs/builtin/#erase-gold","title":"Erase Gold","text":"<p>This job uses the output of the \"Find Beads 3D\" job to erase the gold beads in the un-aligned tilt series. Therefore, subsequent denoising and particle reconstruction using output tilt series from this job will not be affected by the strong contrast of the gold beads.</p>"},{"location":"external_jobs/builtin/#inspect-particles","title":"Inspect Particles","text":"<p>This job simply creates a \"optimisation_set.star\" file from the inputs. The main purpose of this job will be to inspect the filtered particle file after any of the \"Select\" jobs.</p>"},{"location":"external_jobs/dev/","title":"Create External Jobs","text":"<p>RELION has a built-in job called \"External\" that can run any command as a RELION job. This means that if you define the proper wrapper for the command you want to use, you can easily extend RELION.</p> <p>Simple examples are available in the GitHub repository.</p>"},{"location":"external_jobs/dev/#class-structure","title":"Class Structure","text":"<p>All the subclasses of <code>RelionExternalJob</code> will be registered as external jobs. The subclasses must implement <code>output_nodes()</code> and <code>run()</code>.</p> <pre><code>from himena_relion.external import RelionExternalJob\n\nclass MyJob(RelionExternalJob):\n    def output_nodes(self):\n        return [\n            (\"output-particles.star\", \"ParticleGroupMetadata.star\"),\n            (\"output-density.mrc\", \"DensityMap.mrc\"),\n        ]\n\n    def run(\n        self,\n        in_3dref,\n        in_parts,\n        some_param: float,\n    ):\n        # do something with the input files and parameters\n</code></pre> <ul> <li><code>output_nodes()</code> should return a list of (output file name, node type) pairs. The   output file name is relative to the job directory. <code>RelionExternalJob</code> will trust   the output files to be generated by the <code>run()</code> method and will not check the   implementation sanity. The node type should be one of the node types that RELION can   interpret.</li> <li><code>run()</code> should implement the logic of the job. To make the job abortable, <code>run()</code>   should be a generator function in which <code>yield</code> statement is inserted at the   checkpoints.   Following variables are useful for the implementation:</li> <li><code>self.out_job_dir</code> Path ... path to the job directory.</li> <li><code>self.console</code> rich.console.Console ... a console object for printing messages to     the user. <code>self.console.log(\"xyz\")</code> will print \"xyz\" to the run.out file.</li> </ul>"},{"location":"external_jobs/dev/#job-title","title":"Job Title","text":"<p>To make the job more informative, you can override the <code>job_title()</code> class method to provide a custom job title.</p> <pre><code>from himena_relion.external import RelionExternalJob\n\nclass MyJob(RelionExternalJob):\n    ...\n\n    @classmethod\n    def job_title(cls):\n        return \"My Job\"\n</code></pre>"},{"location":"external_jobs/dev/#parameter-types","title":"Parameter types","text":"<p>To provide the user interface for the job parameters, <code>himena-relion</code> uses the type-to-widget mapping functionality built by <code>magicgui</code>, with restrictions on the types so that the job parameters can be safely serialized to and deserialized from a job.star file.</p> <p>In short, following parameter types can be immediately used as the type annotations:</p> <ul> <li><code>int</code></li> <li><code>float</code></li> <li><code>str</code></li> <li><code>bool</code></li> <li><code>Path</code> (from <code>pathlib</code>)</li> <li><code>T | None</code> (where <code>T</code> is one of the above.)</li> <li><code>list[T]</code> (where <code>T</code> is one of the above.)</li> <li><code>tuple[T1, T2, ...]</code> (where <code>T1</code>, <code>T2</code>, ... are one of the above.)</li> <li><code>Literal[\"option1\", \"option2\", ...]</code> (from <code>typing</code>)</li> </ul> <p>To improve the user interface, you will usually need to use <code>Annotated</code> type from <code>typing</code> to provide extra information for the widgets.</p> <pre><code>Annotated[\n    int,\n    {\n        \"min\": 0,  # specific to int and float types\n        \"max\": 100,  # specific to int and float types\n        \"step\": 1,  # specific to int and float types\n        \"label\": \"Parameter X\",\n        \"tooltip\": \"This is an integer parameter.\",\n        \"group\": \"Advanced Parameters\",\n    }\n]\n</code></pre>"},{"location":"external_jobs/dev/#the-reserved-parameter-names","title":"The reserved parameter names","text":"<p>Following parameter names are reserved for RELION and can be used in the <code>run()</code> method. These parameters do not need type annotations.</p> <ul> <li><code>in_3dref</code> ... Reference map</li> <li><code>in_coords</code> ... Picked particle coordinates</li> <li><code>in_mask</code> ... Mask</li> <li><code>in_mics</code> ... Micrographs</li> <li><code>in_movies</code> ... Movies</li> <li><code>in_parts</code> ... Particles</li> <li><code>j</code> ... Number of threads to use</li> </ul>"},{"location":"external_jobs/dev/#widget-for-your-job","title":"Widget For Your Job","text":"<p>If defined, <code>provide_widget()</code> will be called when the job window is opened. This method must return a Qt widget</p> myjob.py<pre><code>class MyJob(RelionExternalJob):\n    ...\n\n    def provide_widget(self, job_dir):\n        return QMyJobWidget(job_dir)\n</code></pre> <p><code>job_dir</code> is a <code>JobDirectory</code> object. This object is implemented with properties and methods that are useful for the manipulation of the job content.</p> <ul> <li><code>job_dir.path</code> ... absolute path to the job directory.</li> <li><code>job_dir.relion_project_dir</code> ... absolute path to the RELION project directory.</li> <li><code>job_dir.make_relative_path(path)</code> ... convert to the path relative to the RELION project (like <code>\"Class2D/job020/job.star\"</code>).</li> <li><code>job_dir.resolve_path(path)</code> ... convert to the absolute path.</li> </ul> <p>The Qt widget class to be returned can be any class that inherits from <code>QWidget</code>. To listen to the updates of the job content, you can implement the <code>on_job_updated(job_dir, path)</code> method in the widget class. This method will be called when the <code>path</code> file under the <code>job_dir</code> is updated.</p> <pre><code>from qtpy import QtWidgets as QtW\n\nclass QMyJobWidget(QtW.QWidget):\n    def __init__(self, job_dir):\n        super().__init__()\n        # build your custom widget here\n\n    def on_job_updated(self, job_dir, path):\n        # this method will be called when the `path` file under the `job_dir` is\n        # updated.\n        ...\n</code></pre>"},{"location":"external_jobs/dev/#run-your-job","title":"Run Your Job","text":"<p><code>himena</code> can also install a .py file as a plugin. You can run the following command for testing and actually running your jobs.</p> <pre><code>himena relion --install myjob.py\n</code></pre> <p>If the installation succeeds, you should see the file is listed under the \"Plugins\" panel of the setting dialog (Ctrl+,)</p> <p></p> <p>and your job is discoverable in the command palette (Ctrl+Shift+P).</p>"},{"location":"external_jobs/dev/#distribute-as-a-plugin","title":"Distribute As A Plugin","text":"<p>Since your RELION plugin is just a Python module, you can distribute it as a <code>pip</code>-installable package. You need to specify the entry point in your <code>pyproject.toml</code> file as follows.</p> pyproject.toml<pre><code>[project.entry-points.\"himena.plugin\"]\n\"My RELION Plugin\" = mymodule.mysubmodule.myjob\n</code></pre> <p>Please refer to the <code>himena</code> plugin system for more details.</p>"}]}